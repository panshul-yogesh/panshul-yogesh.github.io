{
  "title": "AFL content",
  "content": "<div class=\"mw-parser-output\"><p class=\"mw-empty-elt\">\n</p><p><span style=\"color: rgb(0, 115, 231); font-family: Roboto, sans-serif; font-size: 24px;\">System requirements</span></p>\n<ul>\n<li>Java 1.8 </li>\n<li>NET Framework 4.0 (for creating .NET actions) </li>\n<li>Maven 3.2.1</li>\n<li>Java IDE (optionally, you may want to install a Java IDE with Maven support, like Eclipse or IntelliJ) </li>\n</ul>\n<h2 id=\"Prerequisites\">Prerequisites</h2>\n<p>Developing new actions in Advanced Flow Language (AFL) content requires Java or .NET knowledge. Before starting to develop new actions, make sure to:</p>\n<ul>\n<li>install Maven for resolving dependencies and building the project</li>\n<li>read the <a href=\"https://maven.apache.org/guides/getting-started/index#%24filename\">Maven getting started guide</a> </li>\n</ul>\n<h2 id=\"OO_plugins\">OO plugins </h2>\n<p>To create new content for Operations Orchestration 2018.5  and later, you need to develop an extension called a plugin. An OO plugin is a JAR file, packaged as a Maven plugin that contains one or multiple actions. Each plugin defines its own isolated classpath. Classpath isolation ensures that different plugins can use conflicting dependencies. For example, plugin A can use dependency X version 1.0, and plugin B can use the same X dependency, but with version 2.0. Classpath isolation ensures that you can use both plugins in the same flow regardless of the conflicting classpath issue.</p>\n<p>Operations Orchestration 2018.5 and later provides a simple way for creating Java actions by introducing the @Action annotation. Operation Orchestration can also execute .NET actions. Actions written in .NET are referenced by a wrapping Java plugin. The .NET content here is referenced to C# content.</p>\n<h2 id=\"Develop_Actions_annotations\">Develop Actions annotations </h2>\n<p>An action is a method that has the <strong><code>@com.hp.oo.sdk.content.annotations.Action</code></strong> annotation.<b> @Action</b> must be applied on Java methods that conform to the signature:</p>\n<pre><code>@Action\npublic Map&lt;String, String&gt; doSomething(parameters)</code></pre>\n<p>The <strong>@Action</strong> annotation is invoked during flow execution, and specifies the following action information:</p>\n<ul>\n<li><b>name</b>: name of the action</li>\n<li><b>outputs</b>: action outputs</li>\n<li><b>responses</b>: action responses</li>\n</ul>\n<h2 id='\"Hello_World!\"_example'>\"Hello World!\" example</h2>\n<p>Belois a simple <b>\"Hello World!\"</b> action example:</p>\n<pre>public class MyActions {\n@Action\npublic void sayHello() {\nSystem.out.println(\"Hello World!\");\n}\n}</pre>\n<p>By default, the created @Action is named after the method that defines it. In the \"Hello World!\" example, the @Action name is <b>sayHello</b>. The @Action name is used in the operation's definition. The operation is the means to expose an @Action to Studio and to flow authors. Each operation points to a specific groupId, artifactId, version, and @Action name (GAV+@Action name).</p>\n<p>You can customize the @Action name and provide a name that is different from the method name. You can do this using the @Action annotation value parameter. The following code defines the same \"Hello World!\" @Action, but names it my-hello-action:</p>\n<pre>public class MyActions {\n@Action(“my-hello-action”)\npublic void sayHello() {\nSystem.out.println(\"Hello World!\");\n}\n}</pre>\n<h3 id=\"Pass_arguments_to_@Actions\">Pass arguments to @Actions</h3>\n<p>An @Action is exposed to the flow context and can request parameters from it. The flow context holds the state of the flow. For example, consider the following @Action, which adds two numbers and prints the result to the console:</p>\n<pre>@Action\npublic void sum(int x, int y){\nSystem.out.println(x+y);\n}</pre>\n<p>Parameters are taken from the context by name. The sum method requests two integer parameters x and y from the context. When invoking the @Action, Operations Orchestration assigns the value of x and y from the context to the method arguments with the same name.</p>\n<p>Just like with @Action, it is possible to customize parameter names and request that Operations Orchestration resolves the value while using a custom name. In the following example, the sum method requests that the context op1 parameter is assigned to the x argument and op2 to the y argument:</p>\n<pre>@Action\npublic void sum(@Param(\"op1\") int x, @Param(\"op2\") int y){\nSystem.out.println(x+y);\n}</pre>\n<p>The classes <code>ResponseNames</code>, <code>ReturnCodes</code>, <code>InputNames</code>, and <code>OutputNames</code>, under the <code>com.hp.oo.sdk.content.constants</code> package, include commonly used constants, which you can use in the @Action.</p>\n<p>For example, input names such as HOST, USERNAME, PASSWORD, PORT, and so on, or response names such as SUCCESS, FAILURE, NO_MORE, and so on. (CS and AFL)</p>\n<h3 id=\"Return_values\">Return values</h3>\n<p>An @Action, like any Java method, can also return a single value. The returned value is considered the return result of the @Action and is used as return result in the operation. It is also possible for an @Action to return multiple results to the operation. This is done by returning a Map&lt;String, String&gt;, where the Map key is the name of the result, and the associated value is the result value. Returning a Map&lt;String, String&gt; is a way for an @Action to pass multiple outputs to the operation at runtime.</p>\n<h3 id=\"Add_@Action_annotations\">Add @Action annotations</h3>\n<p>@Action annotations are used to generate new operations in the Studio. When generating an @Action based operation, the new operation’s initial attributes (description, inputs, outputs, responses) are taken from the @Action annotations definitions.</p>\n<p>When developing plugins, you must correctly annotate the actions that return only a single value. The annotation has to declare an output with the special name <code>singleResultKey</code>. There is a constant <code>ActionExecutionGoal.SINGLE_RESULT_KEY</code> that assists you, for example:</p>\n<pre>@Action(name = \"modulo-ten\",\ndescription = \"returns the last digit\",\noutputs = @Output(ActionExecutionGoal.SINGLE_RESULT_KEY),\nresponses = @Response(text = ResponseNames.SUCCESS,\nfield = OutputNames.RETURN_RESULT,\nvalue = \"0\", matchType = MatchType.ALWAYS_MATCH,\nresponseType = ResponseType.RESOLVED)\n)\npublic int moduloTen(@Param(\"number\") int number) {\nreturn number % 10;\n}</pre>\n<p>It is important that you use @Action annotations; otherwise, operations created from these @Actions are harder to use.</p>\n<h3 id=\"Annotations\">Annotations</h3>\n<p>Adding metadata means adding or setting the relevant annotations and their attributes. The following table describes the @Action, @Output, @Response and @Param annotations:</p>\n<h4 id=\"Action\">Action</h4>\n<p>The <code>@com.hp.oo.sdk.content.annotations.Action</code> annotation specifies information on an action.</p>\n<p><b>Attributes</b>:</p>\n<ul>\n<li>value (optional): the name of the @Action</li>\n<li>description (optional)</li>\n<li>Output[] (optional): array of outputs (see below)</li>\n<li>Response[] (optional): array of responses (see below)</li>\n</ul>\n<p><b>Comments</b>:</p>\n<p>You have two options for setting the name of the @Action:</p>\n<ol>\n<li>\n<p>The value attribute:</p>\n<p><code>@Action(\"aflPing\") public void ping(…)</code></p>\n<p>or</p>\n<p><code>@Action(value=\"aflPing\") public void ping(…)</code></p>\n</li>\n<li>\n<p>The method name:</p>\n<pre>@Action\npublic void ping(…)</pre>\n</li>\n</ol>\n<p>The names are checked in the above order. The first one checked is the value attribute. If it doesn’t exist, the method name is selected.</p>\n<h4 id=\"Param\">Param</h4>\n<p>The <code>@com.hp.oo.sdk.content.annotations.Param</code> annotation specifies information on a parameter of an action.</p>\n<p><b>Attributes</b>:</p>\n<ul>\n<li>value: the name of the input</li>\n<li>required (optional): by default is false</li>\n<li>encrypted (optional): by default is false</li>\n<li>description (optional)</li>\n</ul>\n<p><b>Comments</b>:</p>\n<p>This is important not only for the @Action data, but also for execution.</p>\n<p>Inputs give an operation or flow the data needed to act upon. Each input is mapped to a variable. You can create an input for a flow, operation, or step.</p>\n<p>In Studio, inputs can be:</p>\n<ul>\n<li>Set to a specific value</li>\n<li>Obtained from information gathered by another step</li>\n<li>Entered by the person running the flow, at the start of the flow</li>\n</ul>\n<h4 id=\"Output\">Output</h4>\n<p>The <code>@com.hp.oo.sdk.content.annotations.Output</code> specifies an output for an action.</p>\n<p><b>Attributes</b>:</p>\n<ul>\n<li>value: the name of the output</li>\n<li>description (optional)</li>\n</ul>\n<p><b>Comments</b>:</p>\n<p>In order for the operation in Studio to have multiple outputs, the @Action itself has to declare them. Assigning values to multiple outputs can be achieved by creating an @Action whose return value is a Map&lt;String, String&gt;.</p>\n<p>In order for the operation in studio to have only one output, the @Action itself has to declare it in the return value, and use the <code>SINGLE_RESULT_KEY</code> for binding.</p>\n<p>The output is the data produced by an operation or flow. For example, success code, output string, error string, or failure message.</p>\n<p>In Studio, the different kinds of operation outputs include:</p>\n<ul>\n<li>Raw result: the entire returned data (return code, data output, and error string).</li>\n<li>The primary and other outputs, which are portions of the raw result.</li>\n</ul>\n<h4 id=\"Response\">Response</h4>\n<p>The <code>@com.hp.oo.sdk.content.annotations.Action</code> annotation specifies a possible response of an action.</p>\n<p><b>Attributes</b>:</p>\n<ul>\n<li><code>text</code>: the text displayed by each response transition</li>\n<li><code>field</code>: the field to evaluate</li>\n<li><code>value</code>: the expected value in the field</li>\n<li><code>description</code>: (optional)</li>\n<li><code>isDefault</code>: Indicates whether this is the default response. The default value is false. Only one response in a @Action can have this set to true.</li>\n<li><code>mathType</code> : The type of matcher to activate against the value. For example if we defined (field = fieldName, value = 0, matchType = COMPARE_GREATER) this means that this response will be chosen if the field fieldName will have a value greater than 0.</li>\n<li><code>responseType</code>: The type of the response (Success, Failure, Diagnosed, No_Action or Resolve_By_Name).</li>\n<li><code>isOnFail</code>: Indicates whether this is the On-Fail response. The default value is false. Only one response in a @Action can have this set to true.</li>\n<li><code>ruleDefined</code>: Indicates whether or not this response has a rule defined. Responses that have no rules defined can be used as the default response. There should be only one response without a rule defined in a single @Action.</li>\n</ul>\n<p><b>Comments</b>:</p>\n<p>A response is the possible outcome of an operation or flow. The response contains a single rule: field matches value.</p>\n<h3 id=\"@Action_data_definition_example\">@Action data definition example</h3>\n<pre>description = &amp;quot;perform a dummy ping&amp;quot;, outputs = {@Output(value = RETURN_RESULT, description =&amp;quot;returnResult description&amp;quot;), @Output(RETURN_CODE), @Output(&amp;quot;packetsSent&amp;quot;), @Output(&amp;quot;packetsReceived&amp;quot;), @Output(&amp;quot;percentagePacketsLost&amp;quot;), @Output(&amp;quot;transmissionTimeMin&amp;quot;), @Output(&amp;quot;transmissionTimeMax&amp;quot;), @Output(&amp;quot;transmissionTimeAvg&amp;quot;)}, responses = {@Response(text = &amp;quot;success&amp;quot;, field = RETURN_CODE, value = PASSED), @Response(text = &amp;quot;failure&amp;quot;, field = RETURN_CODE, value = FAILED)}) public Map&amp;lt;String, String&amp;gt; doPing( @Param(value = &amp;quot;targetHost&amp;quot;, required = true, encrypted = false, description = &amp;quot;the host to ping&amp;quot;) String targetHost, @Param(&amp;quot;packetCount&amp;quot;) String packetCount, @Param(&amp;quot;packetSize&amp;quot;) String packetSize) { … }\n</pre>\n<h2 id=\"Text_extensions\">Text extensions </h2>\n<p>As an @Action is a simple Java method, it is possible to test it using standard Java test tools such as JUnit, leveraging the normal lifecycle phases of a Maven project.</p>\n<p>As the @Action itself is a regular method, it does not require invoking any Operations Orchestration components. The invocation can be a direct Java method invocation in the test case.</p>\n<h3 id=\"Test_extensions_as_part_of_the_project_build\">Test extensions as part of the project build</h3>\n<p>Once they are packaged into a plugin, you can invoke extensions from the command line for test purposes. The following is an @Action example:</p>\n<pre>public class TestActions { \n@Action\npublic int sum(@Param(&amp;quot;op1&amp;quot;) int x, @Param(&amp;quot;op2&amp;quot;) int y){ \nreturn x+y; \n} \n}\n</pre>\n<p>Suppose the TestActions class is in a plugin with the following groupId, artifactId and version (GAV): com.mycompany:my-actions:1.0</p>\n<p>You can invoke the sum @Action from the command line as follows:</p>\n<pre>mvn com.mycompany:my-actions:1.0:execute -Daction=sum -Dop1=1 -Dop2=3 -X\n</pre>\n<p>The result of this command is a long trace. The -X option is required to see log messages. Towards the end of the trace you can see:</p>\n<pre>[DEBUG] Configuring mojo 'com.mycompany:my-actions:1.0::execute' with basic configurator --&amp;gt; [DEBUG] (f) actionName = sum [DEBUG] (f) session = org.apache.maven.execution.MavenSession@21cfa61c [DEBUG] -- end configuration -- [DEBUG] Action result: action result = 4\n</pre>\n<p class=\"mw-empty-elt\"></p></div>",
  "modifiedon": "2025-10-24 08:51:12"
}