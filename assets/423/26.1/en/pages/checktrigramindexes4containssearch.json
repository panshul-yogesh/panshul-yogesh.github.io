{
  "title": "Check trigram indexes for the Contains search",
  "content": "<div class=\"mw-parser-output\"><p class=\"mw-empty-elt\">\n</p><p id='Enable_the_\"Contains\"_search_for_entity_pickers_and_text_filters'>To ensure good performance of the Contains search functionality, valid <strong>trigram</strong> indexes must exist in the <strong>xservices_ems</strong> database in your environment. There's a chance that the creation of the required <strong>trigram</strong> indexes fails in your environment, for example, if you've upgraded your suite environment from a fresh installation of version 2022.11 or earlier. You can use your database admin user or the <strong>maas_admin</strong> user to manually check if the valid <strong>trigram</strong> indexes exist in the database, and if not manually create them. </p>\n<h2>Check trigram indexes for out-of-the-box record types</h2>\n<p>Use the following procedure to check if <strong>trigram</strong> indexes have been created successfully for out-of-the-box record types:</p>\n<ol>\n<li>\n<p>Run the following SQL commands on the <strong>xservices_ems</strong> database to create a series of SQL functions:</p>\n<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nCREATE OR REPLACE FUNCTION generateSingleFieldTGRMIndexPerTenant(p_tenant_id varchar, p_entity_name varchar, logical_field varchar, INOUT result_array text[])\nRETURNS text[] AS\n$BODY$\nDECLARE\n  v_table_ddl   text;\n  v_version     text;\n  v_index_name  text;\n  v_head        text := 'CREATE INDEX CONCURRENTLY IF NOT EXISTS ';\n  v_field       text ;\n  v_where_condition text;\n  v_table_name      text;\n  v_field_name      text;\n  v_indisvalid   BOOLEAN;\n  v_current_index_name text;\nBEGIN \n  SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n  CASE\n  WHEN  p_entity_name='ServiceLevelTarget'  THEN\n    SELECT 'slt_targets_'||p_tenant_id||'_trgm_'||id||'_entity_type' ,'slt_targets_'||p_tenant_id, 'entity_type', 'is_deleted = false'\n\t  into v_index_name, v_table_name, v_field_name, v_where_condition\n      FROM entity_descriptor where tenant_id=v_version and name=p_entity_name;\t  \n  ELSE\n    SELECT 'entities_'||p_tenant_id||'_trgm_'||ed.id||'_'||em.physical_type_name, \n\t  'entities_'||p_tenant_id, em.physical_type_name,'entity_type_id = '||ed.id||' AND is_deleted = false'  \n\t  into v_index_name, v_table_name, v_field_name, v_where_condition\n      FROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n    WHERE em.entity_type = p_entity_name and em.logical_type_name = logical_field and em.tenant_id = v_version and ed.name = em.entity_type;\t\n  END CASE;  \n  SELECT i.indisvalid, c.relname \n    INTO  v_indisvalid, v_current_index_name\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid \n      INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i'  AND s.relname = v_table_name AND o.opcname = 'gin_trgm_ops'  AND a.attnum &gt; 0 \n\t  AND pg_get_expr(i.indpred, i.indrelid, true) = v_where_condition AND a.attname = v_field_name;\n  IF v_indisvalid = false THEN\t \n\t  v_table_ddl := 'DROP INDEX '||v_current_index_name||'; --invalid Index';\n\t  RAISE NOTICE '%', v_table_ddl;\n\t  execute format(v_table_ddl);\t  \n  ELSIF v_indisvalid = true THEN\n\t  RAISE NOTICE '--Valid index: \"%\" ; Entity: [%], Field: [%])', v_current_index_name, p_entity_name, logical_field; \n\t  RETURN;\n  END IF;\n\n  v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING gin (('||v_field_name||') gin_trgm_ops) WHERE '||v_where_condition||';';\n  result_array := array_append(result_array, v_table_ddl); \n  RETURN;\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n---------------------------------------\n---------------------------------------  \nCREATE OR REPLACE FUNCTION generateCompoundTRGMIndexPerTenant(p_tenant_id varchar, p_entity_name varchar, p_fields text[], INOUT result_array text[])\n  RETURNS text[] AS\n$BODY$\nDECLARE\n  column_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_version     text;\n  v_head        text := 'CREATE INDEX CONCURRENTLY IF NOT EXISTS ';\n  v_field       text ;\n  v_where_condition text;\n  v_table_name      text;\n  v_expr         text;\n  vv_expr        text;\n  v_indisvalid   BOOLEAN;\n  v_index_c      integer;\n  v_current_index_name text;\nBEGIN\n    SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n    FOR column_record IN\n      SELECT ed.id as entity_type_id, ed.name as entity_name, em.logical_type_name as logical_name, em.physical_type_name as physical_type_name\n        FROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n        WHERE em.entity_type = p_entity_name and em.logical_type_name::text = any(p_fields) and em.tenant_id = v_version and ed.name = em.entity_type\n        ORDER by array_positions(p_fields, em.logical_type_name::text)\n    LOOP\n      --RAISE NOTICE 'Value: %',column_record.logical_name;\n      IF column_record.logical_name = p_fields[1]::text THEN\n        v_index_name := 'entities_'||p_tenant_id||'_trgm_'||column_record.entity_type_id||'_'||column_record.physical_type_name;\n        v_expr := 'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n        vv_expr := 'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n      ELSE\n        v_index_name := v_index_name||column_record.physical_type_name;\n        IF column_record.logical_name = p_fields[array_length(p_fields,1)] THEN\n          v_expr := '('||v_expr||' || e''\\x06''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n          vv_expr := '('||vv_expr||' || '''|| e'\\x06'||'''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n        ELSE\n          v_expr := '(('||v_expr||' || e''\\x06''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text)';\n          vv_expr := '(('||vv_expr||' || '''|| e'\\x06'||'''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text)';\n        END IF;\n      END IF;\n    END LOOP;\n    v_table_name :=  'entities_'||p_tenant_id;\n    v_where_condition := 'entity_type_id = '||column_record.entity_type_id||' AND is_deleted = false';\n    v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING gin (('||v_expr||') gin_trgm_ops) WHERE '||v_where_condition||';';\n    --drop the useless index\n    SELECT count(*)\n    INTO  v_index_c\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid\n                         INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND s.relname = v_table_name AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0\n      AND c.relname = v_index_name AND a.attname = 'expr' AND pg_get_expr(i.indexprs, i.indrelid, true) not like '%COALESCE%';\n    IF v_index_c = 1 THEN\n      v_table_ddl := 'DROP INDEX '||v_index_name||'; --drop the useless index.';\n      RAISE NOTICE '%', v_table_ddl;\n      EXECUTE FORMAT(v_table_ddl);\n    END IF;\n    --\n    SELECT i.indisvalid, c.relname\n    INTO  v_indisvalid, v_current_index_name\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid\n      INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND s.relname = v_table_name AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0\n      AND pg_get_expr(i.indpred, i.indrelid, true) = v_where_condition AND a.attname = 'expr' AND pg_get_expr(i.indexprs, i.indrelid, true) = vv_expr;\n\n    if v_indisvalid = false THEN\n      v_table_ddl := 'DROP INDEX '||v_current_index_name||'; --drop the invalid index.';\n      RAISE NOTICE '%', v_table_ddl;\n      EXECUTE FORMAT(v_table_ddl);\n    ELSIF v_indisvalid = true THEN\n      RAISE NOTICE '--Valid index: \"%\" ; Entity: [%], Fields: [%])', v_current_index_name, p_entity_name, p_fields;\n      RETURN;\n    END IF;\n    v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING gin (('||v_expr||') gin_trgm_ops) WHERE '||v_where_condition||';';\n    result_array := array_append(result_array, v_table_ddl);\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n--------------------------------\n--------------------------------\nCREATE OR REPLACE FUNCTION generateCompoundTRGMIndex_c(p_entity_name varchar, p_fields text[])\n  RETURNS text AS\n$BODY$\nDECLARE\ncolumn_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_version     text;\n  v_expr        text;\n  v_field       text ;\n  v_where_condition text;\n  v_table_name      text;\n  v_index_c     integer;\nv_head        text := 'CREATE INDEX IF NOT EXISTS ';\nBEGIN\n  SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n  FOR column_record IN\n  SELECT ed.id as entity_type_id, ed.name as entity_name, em.logical_type_name as logical_name, em.physical_type_name as physical_type_name\n  FROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n  WHERE em.entity_type = p_entity_name and em.logical_type_name::text = any(p_fields) and em.tenant_id = v_version and ed.name = em.entity_type\n  ORDER by array_positions(p_fields, em.logical_type_name::text)\n  LOOP\n    --RAISE NOTICE 'Value: %',column_record.logical_name;\n      IF column_record.logical_name = p_fields[1]::text THEN\n        v_index_name := 'entities_trgm_'||column_record.entity_type_id||'_'||column_record.physical_type_name;\n        v_expr := 'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n      ELSE\n        v_index_name := v_index_name||column_record.physical_type_name;\n        IF column_record.logical_name = p_fields[array_length(p_fields,1)] THEN\n          v_expr := '('||v_expr||' || e''\\x06''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text';\n        ELSE\n          v_expr := '(('||v_expr||' || e''\\x06''::text) || '||'COALESCE('||column_record.physical_type_name||', ''''::character varying)::text)';\n       END IF;\n     END IF;\n  END LOOP;\n  SELECT count(*)\n    INTO  v_index_c\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid\n                         INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND s.relname = 'entities' AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0\n      AND c.relname = v_index_name AND a.attname = 'expr' AND pg_get_expr(i.indexprs, i.indrelid, true) not like '%COALESCE%';\n  IF v_index_c = 1 THEN\n    v_table_ddl := 'DROP INDEX '||v_index_name||'; --drop the useless index.';\n    RAISE NOTICE '%', v_table_ddl;\n    EXECUTE FORMAT(v_table_ddl);\n  END IF;\n  v_table_name :=  'entities';\n  v_where_condition := 'entity_type_id = '||column_record.entity_type_id||' AND is_deleted = false';\n  v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING gin (('||v_expr||') gin_trgm_ops) WHERE '||v_where_condition||';';\n\n  execute format(v_table_ddl);\n  RETURN 'Index '||v_index_name||' is created.';\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n---------------------------------\n---------------------------------\nCREATE OR REPLACE FUNCTION generateTRGMIndexPerTenant(p_tenant_id varchar)\nRETURNS text[] AS\n$BODY$\nDECLARE\n  column_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_str         text := ' ON entities_'||p_tenant_id||' USING gin (';\n  result_array text[] := ARRAY[]::text[]; \nBEGIN   \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Request', 'DisplayLabel', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Request', 'ExternalProcessReference', result_array) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Incident', 'DisplayLabel', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Incident', 'ExternalProcessReference', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Change', 'DisplayLabel', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Change', 'ExternalProcessReference', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Device', 'DisplayLabel', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'SystemElement', 'DisplayLabel', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Person', 'Name', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Person', 'FirstName', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Person', 'LastName', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Person', 'Email', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Person', 'EmployeeNumber', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'PersonGroup', 'Name', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Location', 'DisplayLabel', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Location', 'Name', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Location', 'Code', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'ITProcessRecordCategory', 'DisplayLabel', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'ITProcessRecordCategory', 'Level1Parent', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'ITProcessRecordCategory', 'Level2Parent', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'DashboardDefinition', 'Name', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Task', 'DisplayLabelKey', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Task', 'ParentEntityId', result_array ) into result_array;\n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'CostCenter', 'DisplayLabel', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'CostCenter', 'Code', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Article', 'Title', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'Offering', 'DisplayLabel', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'AssetModel', 'DisplayLabel', result_array ) into result_array; \n  select generateSingleFieldTGRMIndexPerTenant(p_tenant_id, 'ServiceLevelTarget', 'EntityType', result_array ) into result_array; \n  select generateCompoundTRGMIndexPerTenant(p_tenant_id, 'Person', array['Name', 'LastName', 'FirstName', 'EmployeeNumber', 'Email'], result_array ) into result_array; \n  select generateCompoundTRGMIndexPerTenant(p_tenant_id, 'ITProcessRecordCategory',array['DisplayLabel', 'Level1Parent', 'Level2Parent'], result_array ) into result_array; \n  select generateCompoundTRGMIndexPerTenant(p_tenant_id, 'Location', array['Name', 'DisplayLabel', 'Code'], result_array ) into result_array; \n  RAISE NOTICE '------------------------------------------------------';\n  if ARRAY_LENGTH(result_array,1) IS NULL THEN\n    RAISE NOTICE 'For tenant[%], all trigram indexes are created successfully.', p_tenant_id;\n  else \n    RAISE NOTICE 'For tenant[%], created: % , to be created: %.', p_tenant_id, 32-ARRAY_LENGTH(result_array,1), ARRAY_LENGTH(result_array,1);\n  END IF;\n  RAISE NOTICE '------------------------------------------------------';\n  RETURN result_array;\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\t \n---------------------------------\n---------------------------------</code></pre>\n</li>\n<li>Create new compound indexes on table \"entities\" by running the following SQL:\n\t<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nselect generateCompoundTRGMIndex_c('Person', array['Name', 'LastName', 'FirstName', 'EmployeeNumber', 'Email']);\nselect generateCompoundTRGMIndex_c('ITProcessRecordCategory',array['DisplayLabel', 'Level1Parent', 'Level2Parent']);\nselect generateCompoundTRGMIndex_c('Location', array['Name', 'DisplayLabel', 'Code']);</code></pre>\n</li>\n<li>Enter the <strong>xservices_mng</strong> database and create some SQL commands to check the <strong>trigram</strong> indexes for all the tenants. To do this, run the following SQL commands:\n\t<pre>\\c xservices_mng;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nSELECT 'select unnest(generateTRGMIndexPerTenant('''||tenant_id||''')) as \"SQLs:\";' as \"SQLs for all tenants:\"\nFROM data_upgrade_state\nWHERE data_upgrade_version &gt;= 41 and length(tenant_id)=9;\n</pre>\n</li>\n<li>The result contains one or more SQL commands (one SQL command per active tenant). Pick any one command and run it. For example:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nSELECT unnest(generateTRGMIndexPerTenant('&lt;tenant_id&gt;')) as \"SQLs:\";</pre>\n</li>\n<li>The returned result should have this message: \n\t<pre>NOTICE: For tenant[&lt;tenant_id&gt;], created: xx, to be created: yy..</pre>\n\tThere should be 32 indexes in total, and this message means xx out of 32 indexes have been created and yy indexes have not been created. For example, if the message reads \"NOTICE: For tenant[&lt;tenant_id&gt;], created: 00, to be created: 32..\", it means none of the indexes have been created successfully. In addition, this function drops invalid indexes as well. </li>\n<li>If there are indexes missing, manually run the <strong>CREATE INDEXES CONCURRENTLY</strong> SQL commands returned by the <strong>generateTRGMIndexPerTenant</strong> function.<br/>\n<strong>Note</strong> If the returned SQL commands are too long and contain line breakers, you need to remove the line breakers before running them.<br/>\n\tFor example:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS entities_555500002_trgm_369_schar1 ON entities_555500002 USING gin ((schar1) gin_trgm_ops) WHERE entity_type_id = 369 AND is_deleted = false;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS entities_555500002_trgm_369_schar5 ON entities_555500002 USING gin ((schar5) gin_trgm_ops) WHERE entity_type_id = 369 AND is_deleted = false;</pre>\n</li>\n<li>Run the commands in step 4, if all indexes are created successfully, you should see the following message:\n\t<pre><code>NOTICE: For tenant[&lt;tenant_id&gt;], all trigram indexes are created successfully.</code></pre>\n</li>\n<li>Repeat step 4 to step 7 for all other active tenants.</li>\n<li>Drop the functions created in step 1:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nDROP FUNCTION generateTRGMIndexPerTenant;\nDROP FUNCTION generateCompoundTRGMIndexPerTenant;\nDROP FUNCTION generateSingleFieldTGRMIndexPerTenant;\nDROP FUNCTION generateCompoundTRGMIndex_c;</pre>\n</li>\n</ol>\n<h2>Check trigram indexes for custom record types</h2>\n<p>Use the following procedure to check if valid <strong>trigram</strong> indexes have been created successfully for your custom record types:</p>\n<ol>\n<li>\n<p>Run the following SQL commands on the <strong>xservices_ems</strong> database to create a function:</p>\n<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nCREATE OR REPLACE FUNCTION generateCustomTRGMIndexPerTenant(p_tenant_id varchar)\n  RETURNS text[] AS\n$BODY$\nDECLARE\n  column_record record;\n  v_table_ddl       text;\n  v_index_name      text;\n  v_version         text;\n  v_head            text := 'CREATE INDEX CONCURRENTLY IF NOT EXISTS ';\n  v_field           text ;\n  v_entity_type_id  text;\n  v_where_condition text;\n  v_table_name      text;\n  v_indisvalid      BOOLEAN;\n  v_current_index_name text;\n  result_array      text[] := ARRAY[]::text[]; \n  v_created_cnt     integer := 0; \n  v_byoa_entity_cnt integer := 0;\nBEGIN\n  FOR column_record IN \n    SELECT ed.id as entity_type_id, ed.name as entity_name, em.logical_type_name as logical_name, em.physical_type_name as physical_type_name\n\tFROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n    WHERE em.logical_type_name='DisplayLabel' and em.tenant_id = p_tenant_id\n  LOOP\t\n\tv_index_name := 'entities_'||p_tenant_id||'_trgm_'||column_record.entity_type_id||'_'||column_record.physical_type_name;    \n\tv_table_name :=  'entities_'||p_tenant_id;\n\tv_where_condition := 'entity_type_id = '||column_record.entity_type_id||' AND is_deleted = false';\n\tv_byoa_entity_cnt := v_byoa_entity_cnt + 1;\n    SELECT i.indisvalid, c.relname \n    INTO  v_indisvalid, v_current_index_name\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid \n      INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i'  AND s.relname = v_table_name AND o.opcname = 'gin_trgm_ops'  AND a.attnum &gt; 0 \n\t   AND pg_get_expr(i.indpred, i.indrelid, true) = v_where_condition AND a.attname = column_record.physical_type_name;\n    IF v_indisvalid = false THEN\t \n\t  v_table_ddl := 'DROP INDEX '||v_current_index_name||'; --invalid Index';\n\t  RAISE NOTICE '%', v_table_ddl;\n\t  execute format(v_table_ddl);\t  \n    ELSIF v_indisvalid = true THEN\n\t  RAISE NOTICE '--Valid index: \"%\" ; Custom Entity: [%], Field: [%]', v_current_index_name, column_record.entity_name, column_record.logical_name; \n\t  v_created_cnt := v_created_cnt + 1;\n\t  CONTINUE;\n    END IF; \n    v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING gin (('||column_record.physical_type_name||') gin_trgm_ops) WHERE '||v_where_condition||';';\n    result_array := array_append(result_array, v_table_ddl);\n  END LOOP;\n  RAISE NOTICE '------------------------------------------------------';\n  IF v_byoa_entity_cnt = 0 THEN\n    RAISE NOTICE 'There are no custom record types for tenant[%].', p_tenant_id;\n  ELSIF ARRAY_LENGTH(result_array, 1) IS NULL THEN\n    RAISE NOTICE '[Custom] For tenant[%], all trigram indexes are created successfully.', p_tenant_id;\n  ELSE\n    RAISE NOTICE '[Custom] For tenant[%], created: % , to be created: %.', p_tenant_id, v_created_cnt, ARRAY_LENGTH(result_array,1);\n  END IF;\n  RAISE NOTICE '------------------------------------------------------';\n  RETURN result_array;\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n</code></pre>\n</li>\n<li>Enter the <strong>xservices_mng</strong> database and create some SQL commands to check the <strong>trigram</strong> indexes for all the tenants. To do this, run the following SQL commands:\n\t<pre>\\c xservices_mng;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nSELECT 'select unnest(generateCustomTRGMIndexPerTenant('''||tenant_id||''')) as \"SQLs:\";' as \"SQLs for all tenants:\"\nFROM data_upgrade_state\nWHERE data_upgrade_version &gt;= 41 and length(tenant_id)=9;\n</pre>\n</li>\n<li>The result contains one or more SQL commands (one SQL command per active tenant). Pick any one command and run it. For example:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nSELECT unnest(generateCustomTRGMIndexPerTenant('&lt;tenant_id&gt;')) as \"SQLs:\";</pre>\n</li>\n<li>The returned result should have this message: \n\t<pre>NOTICE:  [Custom] For tenant[&lt;tenant_id&gt;], created: xx , to be created: yy.</pre>\n\tThis message means xx indexes have been created and yy indexes have not been created. For example, if the message reads \"NOTICE:  [Custom] For tenant[&lt;tenant_id&gt;], created: 0, to be created: 2.\", it means none of the indexes have been created successfully. In addition, this function drops invalid indexes as well. <br/>\n\tIf there're no custom record types in this tenant, you would have this message:\n\t<pre>NOTICE: There are no custom record types for tenant[&lt;tenant_id&gt;<tenant_id>].  </tenant_id></pre>\n</li>\n<li>If there are indexes missing, manually run the <strong>CREATE INDEXES CONCURRENTLY</strong> SQL commands returned by the <strong>generateCustomTRGMIndexPerTenant</strong> function.<br/>\n<strong>Note</strong> If the returned SQL commands are too long and contain line breakers, you need to remove the line breakers before running them.<br/>\n\tFor example:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS entities_555500001_trgm_10001_uchar2 ON entities_555500001 USING gin ((uchar2) gin_trgm_ops) WHERE entity_type_id = 10001 AND is_deleted = false;\nCREATE INDEX CONCURRENTLY IF NOT EXISTS entities_555500001_trgm_10002_uchar1 ON entities_555500001 USING gin ((uchar1) gin_trgm_ops) WHERE entity_type_id = 10002 AND is_deleted = false;</pre>\n</li>\n<li>Run the commands in step 3, if all indexes are created successfully, you should see the following message:\n\t<pre><code>NOTICE: [Custom] For tenant[&lt;tenant_id&gt;], all trigram indexes are created successfully.</code></pre>\n</li>\n<li>Repeat step 3 to step 6 for all other active tenants.</li>\n<li>Drop the functions created in step 1:\n\t<pre>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nDROP FUNCTION generateCustomTRGMIndexPerTenant;\n</pre>\n</li>\n</ol>\n<h2>Delete unused compound indexes</h2>\n<p>Follow the steps below to delete unused compound indexes from the <strong>xservices_ems</strong> database: </p>\n<ol>\n<li>\n<p>Run the following SQL commands on the <strong>xservices_ems</strong> database to create a series of SQL functions:</p>\n<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nCREATE OR REPLACE FUNCTION dropCompoundTRGMIndexByName(p_entity_name varchar, p_fields text[])\n--Drop the compound indexes on the table \"entities\" where the order of the columns is not as expected.\n  RETURNS void AS\n$BODY$\nDECLARE\ncolumn_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_version     text;\n  v_expr        text;\n  v_field       text ;\n  v_where_condition text;\n  v_table_name      text;\n  v_index_c     integer;\nBEGIN\n  SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n  FOR column_record IN\n  SELECT ed.id as entity_type_id, ed.name as entity_name, em.logical_type_name as logical_name, em.physical_type_name as physical_type_name\n  FROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n  WHERE em.entity_type = p_entity_name and em.logical_type_name::text = any(p_fields) and em.tenant_id = v_version and ed.name = em.entity_type\n  ORDER by array_positions(p_fields, em.logical_type_name::text)\n  LOOP\n    --RAISE NOTICE 'Value: %',column_record.logical_name;\n      IF column_record.logical_name = p_fields[1]::text THEN\n        v_index_name := 'entities_trgm_'||column_record.entity_type_id||'_'||column_record.physical_type_name;       \n      ELSE\n        v_index_name := v_index_name||column_record.physical_type_name;        \n     END IF;\n  END LOOP;\n  SELECT count(*)\n    INTO  v_index_c\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid\n         INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND s.relname = 'entities' AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0\n      AND c.relname = v_index_name AND a.attname = 'expr';\n  IF v_index_c = 1 THEN\n    v_table_ddl := 'DROP INDEX '||v_index_name||'; ';\n    RAISE NOTICE '%', v_table_ddl;\n    EXECUTE FORMAT(v_table_ddl);\n  END IF;\n  --RETURN 'Drop the unused index ['||v_index_name||'] for entity \"'||p_entity_name||'\".';\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n--------------------------------------------\n--------------------------------------------\nCREATE OR REPLACE FUNCTION dropCompoundTRGMIndexPerTenant(p_tenant_id varchar, p_entity_name varchar, p_fields text[])\n--Drop the compound indexes on the tables \"entities_&lt;tenantid&gt;\" where the order of the columns is not as expected.\n  RETURNS void AS\n$BODY$\nDECLARE\n  column_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_version     text;\n  v_field       text ;\n  v_table_name      text;\n  v_index_c      integer;\nBEGIN\n    SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n    FOR column_record IN\n      SELECT ed.id as entity_type_id, ed.name as entity_name, em.logical_type_name as logical_name, em.physical_type_name as physical_type_name\n        FROM entityDescriptor_mapping em join entity_descriptor ed on (ed.name = em.entity_type and ed.tenant_id = em.tenant_id)\n        WHERE em.entity_type = p_entity_name and em.logical_type_name::text = any(p_fields) and em.tenant_id = v_version and ed.name = em.entity_type\n        ORDER by array_positions(p_fields, em.logical_type_name::text)\n    LOOP\n      --RAISE NOTICE 'Value: %',column_record.logical_name;\n      IF column_record.logical_name = p_fields[1]::text THEN\n        v_index_name := 'entities_'||p_tenant_id||'_trgm_'||column_record.entity_type_id||'_'||column_record.physical_type_name;\n      ELSE\n        v_index_name := v_index_name||column_record.physical_type_name;\n      END IF;\n    END LOOP;\n   \n    --drop the useless index\n    SELECT count(*)\n    INTO  v_index_c\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0 AND c.relname = v_index_name AND a.attname = 'expr';\n    IF v_index_c = 1 THEN\n      v_table_ddl := 'DROP INDEX '||v_index_name||'; --drop the useless index.';\n      RAISE NOTICE '%', v_table_ddl;\n      EXECUTE FORMAT(v_table_ddl);\n    END IF;\n    --drop the index without COALESCE\nEND;\n$BODY$\nLANGUAGE 'plpgsql'; \n\n--------------------------------------------\n--------------------------------------------\nCREATE OR REPLACE FUNCTION dropCompoundTRGMIndexWithUnexpectedOrder(p_entity_name varchar, p_fields text[])\n  RETURNS void AS\n$BODY$\nDECLARE\n  column_record record;\nBEGIN\n  FOR column_record IN\n    SELECT relname as tablename, substring(relname from 10 for 9) as tenant_id from pg_class where relname ~ 'entities_[[:digit:]]' and relkind='r' and length(relname)=18\n  LOOP\n    PERFORM dropCompoundTRGMIndexPerTenant(column_record.tenant_id, p_entity_name, p_fields);\n  END LOOP;\n  PERFORM dropCompoundTRGMIndexByName(p_entity_name, p_fields);  \n  \nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n--------------------------------------------\n--------------------------------------------\nCREATE OR REPLACE FUNCTION dropCompoundTRGMIndexWithoutCOALESCE()\n--Drop the compound indexes where have no function COALESCE().\n  RETURNS void AS\n$BODY$\nDECLARE\ncolumn_record record;\n  v_table_ddl   text;\n  v_index_name  text;\n  v_version     text;\n  v_expr        text;\n  v_field       text ;\n  v_where_condition text;\n  v_table_name      text;\n  v_index_c     integer;\nBEGIN\n  SELECT MAX(tenant_id) INTO v_version FROM \"entity_descriptor\" WHERE LENGTH(tenant_id)=3;\n  FOR column_record IN\n  SELECT c.relname AS indexName,s.relname as tableName\n    FROM pg_attribute a  INNER JOIN pg_class c on c.oid = a.attrelid INNER JOIN pg_index i ON c.oid = i.indexrelid INNER JOIN pg_class s ON i.indrelid = s.oid\n         INNER JOIN pg_opclass as o on o.oid = ANY(i.indclass)\n    WHERE c.relkind = 'i' AND s.relname ~ 'entities*'  AND o.opcname = 'gin_trgm_ops' AND a.attnum &gt; 0 AND a.attname = 'expr' AND pg_get_expr(i.indexprs, i.indrelid, true) not like '%COALESCE%'\n  LOOP\n    v_table_ddl := 'DROP INDEX '||column_record.indexName||'; ';\n    RAISE NOTICE 'Table: \"%\", SQL: %.', column_record.tableName, v_table_ddl;\n    EXECUTE FORMAT(v_table_ddl);\n  END LOOP;\nEND;\n$BODY$\nLANGUAGE 'plpgsql';\n--------------------------------------------\n--------------------------------------------\n</code></pre>\n</li>\n<li>Drop the indexes by running the following SQLs:\n\t<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nDO $$DECLARE\nBEGIN\n  perform   dropCompoundTRGMIndexWithUnexpectedOrder('Person', array['Name',  'FirstName','LastName', 'Email', 'EmployeeNumber']);\n  perform   dropCompoundTRGMIndexWithUnexpectedOrder('Location', array['DisplayLabel','Name',  'Code']);\n  perform   dropCompoundTRGMIndexWithoutCOALESCE();\nEND$$;</code></pre>\n</li>\n<li>Drop the functions created in step 1:\n\t<pre><code>\\c xservices_ems;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nDROP FUNCTION dropCompoundTRGMIndexWithoutCOALESCE();\nDROP FUNCTION dropCompoundTRGMIndexPerTenant(p_tenant_id varchar, p_entity_name varchar, p_fields text[]);\nDROP FUNCTION dropCompoundTRGMIndexWithUnexpectedOrder(p_entity_name varchar, p_fields text[]);\nDROP FUNCTION dropCompoundTRGMIndexByName(p_entity_name varchar, p_fields text[]);</code></pre>\n</li>\n</ol>\n<p class=\"mw-empty-elt\"></p></div>",
  "modifiedon": "2025-10-24 08:51:12"
}