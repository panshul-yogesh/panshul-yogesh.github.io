{
  "title": "Create indexes with the B-tree engine",
  "content": "<div class=\"mw-parser-output\"><p class=\"mw-empty-elt\"></p><div class=\"mw-parser-output\"><p class=\"mw-empty-elt\">\n</p><p>When you encounter slow database query performance and check the SQL, you can find the record type ID and the physical field in the query but don’t know what the record type and the logical field are. This topic aims to help you identify the record type and the logical field on which this SQL query is performing a conditional query. Once you have a clear picture of the record type and logical field experiencing slow database queries, you can follow the instructions in this topic to create B-tree indexes on them to improve the performance. You can create the indexes for either a specified tenant or all tenants.</p>\n<h2>Identify the record type and the logical field</h2>\n<p>Use the appropriate procedure below according to your scenario.</p>\n<h3>If you have the record type ID and physical field</h3>\n<p>A script is provided to help you identify the record type (based on the record type ID) and the logical field (based on the physical field). </p>\n<h4>Parameter introduction</h4>\n<ul>\n<li>p_entity_type_id: record type ID</li>\n<li>p_physical_field: physical field name</li>\n<li>p_tenant_id: tenant id</li>\n</ul>\n<h4>Create a getEntityTypeAndLogicalField function</h4>\n<p>Create a getEntityTypeAndLogicalField function with the following script:</p>\n<pre>CREATE OR REPLACE FUNCTION getEntityTypeAndLogicalField(p_entity_type_id INTEGER, p_physical_field VARCHAR, p_tenant_id VARCHAR DEFAULT '')\nRETURNS TEXT AS \n$BODY$\nDECLARE \n    v_version              TEXT;\n    v_entity_type        TEXT;\n    v_logical_field      TEXT;\nBEGIN\n    SELECT MAX(tenant_id) INTO v_version FROM entity_descriptor WHERE LENGTH(tenant_id)=3;\n\n    SELECT name INTO v_entity_type FROM entity_descriptor WHERE id = p_entity_type_id AND tenant_id IN (v_version, p_tenant_id);\n   \n    IF v_entity_type IS NULL THEN\n        RETURN 'Please check the parameters[p_tenant_id, p_entity_type_id], cannot find the record type with record type id('|| p_entity_type_id||') in tenant('||p_tenant_id||')';\n    END IF;\n   \n    SELECT logical_type_name INTO v_logical_field FROM entitydescriptor_mapping em WHERE entity_type = v_entity_type AND tenant_id IN (v_version, p_tenant_id) AND physical_type_name = p_physical_field;\n   \n    IF v_logical_field IS NULL THEN\n        RETURN 'Please check the parameters[p_physical_field], cannot find the logical field with physical field('||p_physical_field||')';\n    END IF;\n   \n    RETURN 'entity type -&gt;'||v_entity_type||', logical field -&gt;'||v_logical_field;\nEND; \n$BODY$\nLANGUAGE 'plpgsql';</pre>\n<h4>Run the getEntityTypeAndLogicalField function</h4>\n<p>Run the getEntityTypeAndLogicalField function as follows:</p>\n<pre>SELECT getEntityTypeAndLogicalField(&lt;recordtypeID&gt;,'&lt;physicalfieldName&gt;','&lt;tenantID&gt;');\n</pre>\n<p>For example:</p>\n<pre>SELECT getEntityTypeAndLogicalField(147, 'uchar0','100000002');\nSELECT getEntityTypeAndLogicalField(147, 'schar2');</pre>\n<p><strong>Note:</strong> If the parameters are correct, the command will return the record type and the logical field.</p>\n<div><a class=\"image\" href=\"/file/images/e/ef/IndexBtree10.png\" title=\"/file/images/e/ef/IndexBtree10.png\"> <img alt=\"IndexBtree10.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/e/ef/IndexBtree10.png\" height=\"175\" hspace=\"0\" src=\"../../../images/IndexBtree10_93e66ef8.png\" style=\"width: 800px; height: 175px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<h3>If you have the record type and physical field</h3>\n<p>A script is provided to help you identify the record type ID (based on the record type) and logical field (based on the physical field). </p>\n<h4>Parameter introduction</h4>\n<ul>\n<li>p_entity_type: record type</li>\n<li>p_physical_field: physical field name</li>\n<li>p_tenant_id: tenant ID</li>\n</ul>\n<h4>Create a getEntityTypeIdAndLogicalField function</h4>\n<p>Create a getEntityTypeIdAndLogicalField function with the following script:</p>\n<pre>CREATE OR REPLACE FUNCTION getEntityTypeIdAndLogicalField(p_entity_type VARCHAR, p_physical_field VARCHAR, p_tenant_id VARCHAR DEFAULT '')\nRETURNS TEXT AS \n$BODY$\nDECLARE \n    v_version            TEXT;\n    v_entity_type_id     TEXT;\n    v_logical_field      TEXT;\nBEGIN\n    SELECT MAX(tenant_id) INTO v_version FROM entity_descriptor WHERE LENGTH(tenant_id)=3;\n\n    SELECT id INTO v_entity_type_id FROM entity_descriptor WHERE name = p_entity_type AND tenant_id IN (v_version, p_tenant_id);\n   \n    IF v_entity_type_id IS NULL THEN\n        RETURN 'Please check the parameters[p_tenant_id, p_entity_type], cannot find the record type id with record type('|| p_entity_type||') in tenant('||p_tenant_id||')';\n    END IF;\n   \n    SELECT logical_type_name INTO v_logical_field FROM entitydescriptor_mapping em WHERE entity_type = p_entity_type AND tenant_id IN (v_version, p_tenant_id) AND physical_type_name = p_physical_field;\n   \n    IF v_logical_field IS NULL THEN\n        RETURN 'Please check the parameters[p_physical_field], cannot find the logical field with physical field('||p_physical_field||')';\n    END IF;\n   \n    RETURN 'entity type id -&gt;'||v_entity_type_id||', logical field -&gt;'||v_logical_field;\nEND; \n$BODY$\nLANGUAGE 'plpgsql';\n</pre>\n<h4>Run the getEntityTypeIdAndLogicalField  function</h4>\n<p>Run the getEntityTypeIdAndLogicalField function as follows:</p>\n<pre>SELECT getEntityTypeIdAndLogicalField(&lt;recordtypeID&gt;,'&lt;physicalfieldName&gt;','&lt;tenantID&gt;');\n</pre>\n<p>For example:</p>\n<pre>SELECT getEntityTypeIdAndLogicalField('Person','schar0');\nSELECT getEntityTypeIdAndLogicalField('CustomAPP_c','ur1','100000002');</pre>\n<p><strong>Note:</strong> If the parameters are correct, the command will return the record type ID (for your reference) and the logical field.</p>\n<div><a class=\"image\" href=\"/file/images/4/40/IndexBtree11.png\" title=\"/file/images/4/40/IndexBtree11.png\"> <img alt=\"IndexBtree11.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/4/40/IndexBtree11.png\" height=\"153\" hspace=\"0\" src=\"../../../images/IndexBtree11_e0f678c1.png\" style=\"width: 800px; height: 153px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<h2>Create an index for the field with the B-tree engine</h2>\n<p>A script is provided to help you create an index for the logical field of the record type for a specific tenant. </p>\n<h3>Parameter introduction</h3>\n<ul>\n<li>p_tenant_id: tenant id</li>\n<li>p_entity_type: entity type name</li>\n<li>p_logical_field: field name</li>\n<li>p_is_text_upper: Applies to columns of type varchar, true: create index with upper function, false not use upper function</li>\n</ul>\n<h3>Create a generateSingleFieldBTreeIndexForEntitiesPerTenant function</h3>\n<p>Create a generateSingleFieldBTreeIndexForEntitiesPerTenant function with the following script:</p>\n<pre>CREATE OR REPLACE FUNCTION generateSingleFieldBTreeIndexForEntitiesPerTenant(p_tenant_id VARCHAR, p_entity_type VARCHAR, p_logical_field VARCHAR, p_is_text_upper BOOLEAN DEFAULT TRUE)\nRETURNS TEXT AS \n$BODY$\nDECLARE \n    v_version              TEXT;\n    v_entity_type_id     TEXT;\n    v_need_upper         BOOLEAN;\n      v_head                 TEXT := 'CREATE INDEX CONCURRENTLY IF NOT EXISTS ';\n    v_index_name           TEXT;\n    v_table_name           TEXT;\n    v_field_name           TEXT;\n    v_where_condition      TEXT;\n     v_table_ddl            TEXT;\n    v_indisvalid         BOOLEAN;\n    v_current_index_name TEXT;\nBEGIN \n    SELECT MAX(tenant_id) INTO v_version FROM entity_descriptor WHERE LENGTH(tenant_id)=3;\n\n    SELECT id INTO v_entity_type_id FROM entity_descriptor WHERE tenant_id IN (v_version, p_tenant_id) AND name = p_entity_type; \n   \n    SELECT \n    'entities_'||p_tenant_id,\n    'entity_type_id = '||v_entity_type_id||' AND is_deleted = false',  \n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n            TRUE\n        ELSE \n            FALSE\n        END AS v_need_upper,   \n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n               'entities_'||p_tenant_id||'_'||v_entity_type_id||'_upper_'||physical_type_name\n        ELSE \n               'entities_'||p_tenant_id||'_'||v_entity_type_id||'_'||physical_type_name\n    END,\n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n            'upper('||physical_type_name||'::text)'\n    ELSE \n        physical_type_name\n    END\n        INTO v_table_name, v_where_condition, v_need_upper, v_index_name, v_field_name \n    FROM entityDescriptor_mapping  WHERE entity_type = p_entity_type AND logical_type_name = p_logical_field AND tenant_id IN (v_version, p_tenant_id);    \n   \n   \n      IF v_field_name IS NULL THEN     \n          RETURN 'Please check the parameters[p_tenant_id, p_entity_type, p_logical_field]. Make sure the logical field('||p_logical_field||') have defined on the entity type('||p_entity_type||') of the tenant('||p_tenant_id||')';\n       ELSIF v_field_name ~ '^[0-9]*\\.?[0-9]*$' THEN\n           RETURN 'Please check the parameters[p_logical_field], The '||p_logical_field||' field is not supported since the logical type of this field is not stored on the entities table';\n      ELSE\n        RAISE NOTICE '--v_table_name: %, v_where_condition: %, v_need_upper: %, v_index_name: %, v_field_name: %', v_table_name, v_where_condition, v_need_upper, v_index_name, v_field_name;\n      END IF;\n    \n    IF v_need_upper = TRUE THEN\n        SELECT i.indisvalid, c.relname \n            INTO  v_indisvalid, v_current_index_name\n        FROM pg_attribute a  INNER JOIN pg_class c ON c.oid = a.attrelid \n            INNER JOIN pg_index i ON c.oid = i.indexrelid \n            INNER JOIN pg_class s ON i.indrelid = s.oid\n        WHERE \n            c.relkind = 'i'  \n            AND s.relname = v_table_name \n            AND a.attnum &gt; 0 \n            AND pg_get_expr(i.indpred, i.indrelid, TRUE) = v_where_condition \n            AND a.attname = 'upper'\n            AND pg_get_expr(i.indexprs,i.indrelid,TRUE) = v_field_name\n            AND array_length(i.indclass, 1) = 1\n            AND pg_get_indexdef(i.indexrelid) ILIKE '%USING BTREE%';        \n    ELSE \n        SELECT i.indisvalid, c.relname \n            INTO  v_indisvalid, v_current_index_name\n        FROM pg_attribute a  INNER JOIN pg_class c ON c.oid = a.attrelid \n            INNER JOIN pg_index i ON c.oid = i.indexrelid \n            INNER JOIN pg_class s ON i.indrelid = s.oid\n        WHERE \n            c.relkind = 'i'  \n            AND s.relname = v_table_name \n            AND a.attnum &gt; 0 \n            AND pg_get_expr(i.indpred, i.indrelid, TRUE) = v_where_condition \n            AND a.attname = v_field_name\n            AND array_length(i.indclass, 1) = 1\n            AND pg_get_indexdef(i.indexrelid) ILIKE '%USING BTREE%';\n    END IF;\n   \n      IF v_indisvalid = FALSE THEN     \n          v_table_ddl := 'DROP INDEX '||v_current_index_name||'; --invalid Index';\n      RAISE NOTICE '%', v_table_ddl;\n      EXECUTE format(v_table_ddl);      \n      ELSIF v_indisvalid = TRUE THEN\n      RETURN 'An index with the same definition already exists with index name '||v_current_index_name;\n      END IF;\n  \n       v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING btree ('||v_field_name||') WHERE '||v_where_condition||';';\n       RETURN v_table_ddl;    \nEND; \n$BODY$\nLANGUAGE 'plpgsql';\n</pre>\n<h3>Run the generateSingleFieldBTreeIndexForEntitiesPerTenant function</h3>\n<p>Run the generateSingleFieldBTreeIndexForEntitiesPerTenant function as follows:</p>\n<pre>SELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('&lt;tenantID&gt;', '&lt;recordtypeName&gt;', '&lt;logicalfieldName&gt;', true/false);</pre>\n<p>The true/false parameter determines if the upper function is used when creating the index. </p>\n<p>For example:</p>\n<pre>SELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('100000002', 'Incident', 'Name', true);\nSELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('100000002', 'Incident', 'Name', false);\nSELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('100000002', 'Incident', 'Text1_c', false);\nSELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('100000002', 'CustomAPP_c', 'Text1_c', true);\nSELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('100000002', 'CustomAPP_c', 'Text1_c', false);</pre>\n<p><strong>Note:</strong> If the parameters are correct and the same definition index has not been created before, the command will return the create index command.</p>\n<div><a class=\"image\" href=\"/file/images/0/0d/IndexBtree02.png\" title=\"/file/images/0/0d/IndexBtree02.png\"> <img alt=\"IndexBtree02.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/0/0d/IndexBtree02.png\" height=\"139\" hspace=\"0\" src=\"../../../images/IndexBtree02_9836d2cf.png\" style=\"width: 800px; height: 139px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>Now, you can run the returned command to create the index for the specified field.</p>\n<h3>If you need to create indexes for all existing tenants</h3>\n<p>Enter the <strong>xservices_mng</strong> database and create some SQL commands to create the B-tree indexes for all the tenants. To do this, run the following SQL commands:</p>\n<pre>\\c xservices_mng;\nSET SEARCH_PATH=maas_admin,\"$user\", public;\nSELECT 'SELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('''||tenant_id||''',''&lt;recordtypeName&gt;'',''&lt;logicalfieldName&gt;'',true/false);' as \"SQLs for all tenants:\"\nFROM data_upgrade_state where length(tenant_id)=9;</pre>\n<p>For example:</p>\n<pre>SELECT 'SELECT generateSingleFieldBTreeIndexForEntitiesPerTenant('''||tenant_id||''',''Incident'',''DisplayLabel'',false);' as \"SQLs for all tenants:\"\nFROM data_upgrade_state where length(tenant_id)=9;</pre>\n<p>Then, you will get one SQL command for each tenant. </p>\n<div><a class=\"image\" href=\"/file/images/b/b0/IndexBtree05.png\" title=\"/file/images/b/b0/IndexBtree05.png\"> <img alt=\"IndexBtree05.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/b/b0/IndexBtree05.png\" height=\"129\" hspace=\"0\" src=\"../../../images/IndexBtree05_cb690254.png\" style=\"width: 800px; height: 129px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>Run all these commands, they will return the CREATE INDEX commands for all existing tenants.</p>\n<p>Now, you can run the returned commands to create indexes for all existing tenants.</p>\n<h2>Create an index for the field in the entities table with the B-tree engine</h2>\n<p>A script is provided to help you create an index for the logical field of the record type in the entities table. After doing so, the desired index will be created for any newly added tenants in the same farm.</p>\n<h3>Parameter introduction</h3>\n<ul>\n<li>p_entity_type: record type name</li>\n<li>p_logical_field: field name</li>\n<li>p_is_text_upper: Applies to columns of type varchar, true: create index with upper function, false not use upper function</li>\n</ul>\n<h3>Create a generateSingleFieldBTreeIndexForEntities function</h3>\n<p>Create a generateSingleFieldBTreeIndexForEntities function with the following script:</p>\n<pre>CREATE OR REPLACE FUNCTION generateSingleFieldBTreeIndexForEntities(p_entity_type VARCHAR, p_logical_field VARCHAR, p_is_text_upper BOOLEAN DEFAULT TRUE)\nRETURNS TEXT AS \n$BODY$\nDECLARE \n    v_version              TEXT;\n    v_entity_type_id     TEXT;\n    v_need_upper         BOOLEAN;\n      v_head                 TEXT := 'CREATE INDEX CONCURRENTLY IF NOT EXISTS ';\n    v_index_name           TEXT;\n    v_table_name           TEXT;\n    v_field_name           TEXT;\n    v_where_condition      TEXT;\n     v_table_ddl            TEXT;\n    v_indisvalid         BOOLEAN;\n    v_current_index_name TEXT;\nBEGIN \n    SELECT MAX(tenant_id) INTO v_version FROM entity_descriptor WHERE LENGTH(tenant_id)=3;\n\n    SELECT id INTO v_entity_type_id FROM entity_descriptor WHERE tenant_id IN (v_version) AND name = p_entity_type; \n   \n    SELECT \n    'entities',\n    'entity_type_id = '||v_entity_type_id||' AND is_deleted = false',  \n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n            TRUE\n        ELSE \n            FALSE\n        END AS v_need_upper,   \n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n               'entities_'||v_entity_type_id||'_upper_'||physical_type_name\n        ELSE \n               'entities_'||v_entity_type_id||'_'||physical_type_name\n    END,\n    CASE \n        WHEN physical_type_name ILIKE '%char%' AND p_is_text_upper = TRUE THEN \n            'upper('||physical_type_name||'::text)'\n    ELSE \n        physical_type_name\n    END\n        INTO v_table_name, v_where_condition, v_need_upper, v_index_name, v_field_name \n    FROM entityDescriptor_mapping  WHERE entity_type = p_entity_type AND logical_type_name = p_logical_field AND tenant_id IN (v_version);    \n   \n      IF v_field_name IS NULL THEN     \n          RETURN 'Please check the parameters. On entities table only support OOTB entity types and logical fields';\n       ELSIF v_field_name ~ '^[0-9]*\\.?[0-9]*$' THEN\n           RETURN 'Please check the parameters[p_logical_field], The '||p_logical_field||' field is not supported since the logical type of this field is not stored on the entities table';         \n      ELSE\n        RAISE NOTICE '--v_table_name: %, v_where_condition: %, v_need_upper: %, v_index_name: %, v_field_name: %', v_table_name, v_where_condition, v_need_upper, v_index_name, v_field_name;\n      END IF;   \n    \n    IF v_need_upper = TRUE THEN\n        SELECT i.indisvalid, c.relname \n            INTO  v_indisvalid, v_current_index_name\n        FROM pg_attribute a  INNER JOIN pg_class c ON c.oid = a.attrelid \n            INNER JOIN pg_index i ON c.oid = i.indexrelid \n            INNER JOIN pg_class s ON i.indrelid = s.oid\n        WHERE \n            c.relkind = 'i'  \n            AND s.relname = v_table_name \n            AND a.attnum &gt; 0 \n            AND pg_get_expr(i.indpred, i.indrelid, TRUE) = v_where_condition \n            AND a.attname = 'upper'\n            AND pg_get_expr(i.indexprs,i.indrelid,TRUE) = v_field_name\n            AND array_length(i.indclass, 1) = 1\n            AND pg_get_indexdef(i.indexrelid) ILIKE '%USING BTREE%';        \n    ELSE \n        SELECT i.indisvalid, c.relname \n            INTO  v_indisvalid, v_current_index_name\n        FROM pg_attribute a  INNER JOIN pg_class c ON c.oid = a.attrelid \n            INNER JOIN pg_index i ON c.oid = i.indexrelid \n            INNER JOIN pg_class s ON i.indrelid = s.oid\n        WHERE \n            c.relkind = 'i'  \n            AND s.relname = v_table_name \n            AND a.attnum &gt; 0 \n            AND pg_get_expr(i.indpred, i.indrelid, TRUE) = v_where_condition \n            AND a.attname = v_field_name\n            AND array_length(i.indclass, 1) = 1\n            AND pg_get_indexdef(i.indexrelid) ILIKE '%USING BTREE%';\n    END IF;\n   \n      IF v_indisvalid = FALSE THEN     \n          v_table_ddl := 'DROP INDEX '||v_current_index_name||'; --invalid Index';\n      RAISE NOTICE '%', v_table_ddl;\n      EXECUTE format(v_table_ddl);      \n      ELSIF v_indisvalid = TRUE THEN\n      RETURN 'An index with the same definition already exists with index name '||v_current_index_name;\n      END IF;\n  \n       v_table_ddl := v_head||v_index_name||' ON '||v_table_name||' USING btree ('||v_field_name||') WHERE '||v_where_condition||';';\n       RETURN v_table_ddl;    \nEND; \n$BODY$\nLANGUAGE 'plpgsql';\n</pre>\n<h3>Run the generateSingleFieldBTreeIndexForEntities  function</h3>\n<p>Run the generateSingleFieldBTreeIndexForEntities function as follows:</p>\n<pre>SELECT generateSingleFieldBTreeIndexForEntities('&lt;recordtypeName&gt;', '&lt;logicalfieldName&gt;', true/false);</pre>\n<p>The true/false parameter determines if the upper function is used when creating the index. </p>\n<p>For example:</p>\n<pre>SELECT generateSingleFieldBTreeIndexForEntities('Incident', 'DisplayLabel', true);\nSELECT generateSingleFieldBTreeIndexForEntities('Incident', 'DisplayLabel', false);\n</pre>\n<p><strong>Note:</strong> If the parameters are correct and the same definition index has not been created before, the command will return the create index command.</p>\n<div><a class=\"image\" href=\"/file/images/1/1f/IndexBtree03.png\" title=\"/file/images/1/1f/IndexBtree03.png\"> <img alt=\"IndexBtree03.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/1/1f/IndexBtree03.png\" height=\"156\" hspace=\"0\" src=\"../../../images/IndexBtree03_357515b2.png\" style=\"width: 800px; height: 156px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>Now, you can run the returned command to create the index for the specified field in the entities table.</p>\n<h2>Drop the functions</h2>\n<p>If these functions are no longer needed, you can run the following commands to drop them:</p>\n<pre>DROP FUNCTION getEntityTypeAndLogicalField(p_entity_type_id INTEGER, p_physical_field VARCHAR, p_tenant_id VARCHAR);\nDROP FUNCTION getEntityTypeIdAndLogicalField(p_entity_type VARCHAR, p_physical_field VARCHAR, p_tenant_id VARCHAR);\nDROP FUNCTION generateSingleFieldBTreeIndexForEntitiesPerTenant(p_tenant_id VARCHAR, p_entity_type VARCHAR, p_logical_field VARCHAR, p_is_text_upper BOOLEAN);\nDROP FUNCTION generateSingleFieldBTreeIndexForEntities(p_entity_type VARCHAR, p_logical_field VARCHAR, p_is_text_upper BOOLEAN);</pre>\n<p class=\"mw-empty-elt\"></p></div>\n<p class=\"mw-empty-elt\"></p></div>",
  "modifiedon": "2025-10-24 08:51:12"
}