{
  "title": "Request Flows",
  "content": "<div class=\"mw-parser-output\"><p class=\"mw-empty-elt\">\n</p><div>\n<div>\n<div class=\"admonition\">\n<div class=\"admonition-icon admonition-tip-icon\"></div>\n<div class=\"admonition-content admonition-tip-content\">\n<div>\n<div>\n<p><br/>\nAt this point, we have created a functional request management process and have a good start on the complete data model we defined earlier. While we still have a good bit of definition to do, we now have a fairly robust system capable of serving our service request needs.</p>\n<p>To expand on what we have built, we will now inspect the actual processes the system uses to fulfill a user request.<br/>\n </p>\n<div>\n<div><a class=\"image\" href=\"/file/images/9/99/Request_Data_Model.gif\" title=\"/file/images/9/99/Request_Data_Model.gif\"> <img alt=\"Request Data Model.gif\" border=\"0\" file=\"/mediawiki/images/9/99/Request_Data_Model.gif\" height=\"800\" hspace=\"0\" src=\"../../../images/Request_Data_Model_8cc21af4.gif\" style=\"width: 769.691px; height: 800px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"769.690927218345\"/> </a></div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<h2>Request Management Workflows</h2>\n<p>Now that we have set up our request management process components, I thought it would be a good idea to take a step back and see how the process flows from beginning to end. We know the basics of what a request is, right? Someone who consumes one of our services is either:</p>\n<ul>\n<li>requesting something we have pre-defined in our service catalog</li>\n<li>requesting something we don’t have defined, but still related to one of our services</li>\n<li>requesting help with an issue that's causing them to not be able to consume the service</li>\n<li>requesting a service we aren't providing at this time</li>\n<li>requesting something from HR</li>\n<li>requesting multiple items at the same time</li>\n</ul>\n<p>Service Management has a few different workflows defined for requests that handle these possibilities. A workflow is the system’s definition of how a certain process will run. The three primary request workflows in the system are: “Service”, “Support”, “HR Support”, and “cart”. Don’t let the names confuse you, these are all workflows that deal with our service requests (or just ‘requests’ for short).</p>\n<p>The first workflow handles those pre-defined requests, while the second deals with a more unstructured request such as:</p>\n<ul>\n<li>Requests for Information that need to be researched or looked up in the knowledge base (if the end user could not find the information on their own).</li>\n<li>Complaints about a particular service or service component.</li>\n<li>Reports around degradation of service that may or may not be caused by something in our environment</li>\n</ul>\n<p>The third workflow handles requests specific to HR. This allows us to have a specialized process (including approvals) for the HR department.</p>\n<p>The final workflow handles the situation where we allow our end users to create a ‘shopping cart’ that contains multiple selections from our service catalog. When this happens the system creates each specific item as either a “Service”, “Support”, or “HR Support” request, and also creates an additional “Cart” request to handle the overall approvals and provide a single point of entry and communication with the end user.</p>\n<h2>Service Workflow</h2>\n<div><a class=\"image\" href=\"/file/images/2/26/5.4-ServiceWorkflow.png\" title=\"/file/images/2/26/5.4-ServiceWorkflow.png\"> <img alt=\"5.4-ServiceWorkflow.png\" border=\"0\" file=\"/mediawiki/images/2/26/5.4-ServiceWorkflow.png\" height=\"320\" hspace=\"0\" src=\"../../../images/5.4-ServiceWorkflow_c5221441.png\" style=\"width: 800px; height: 320px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>As you can see in the above image, the 'Service' workflow for request consists of discrete phases ('Log', 'Approve', etc.) that take place within higher level steps (such as 'Classification' or 'Approval'). An important point to keep in mind is that the end user will have visibility into what step in the process their request is in, but only the agents can see the full workflow of a request (including the current phase and past phases). An end user will only see the current step and where that lies in the order of all steps for the current process as seen in the image below.</p>\n<div><a class=\"image\" href=\"/file/images/0/0c/5.5-currentPhase.png\" title=\"/file/images/0/0c/5.5-currentPhase.png\"> <img alt=\"5.5-currentPhase.png\" border=\"0\" file=\"/mediawiki/images/0/0c/5.5-currentPhase.png\" height=\"196\" hspace=\"0\" src=\"../../../images/5.5-currentPhase_2af30ced.png\" style=\"width:686px;height:196px;margin-top:0px;margin-bottom:0px;margin-left:0px;margin-right:0px;border:0px solid black;\" vspace=\"0\" width=\"686\"/> </a></div>\n<h3>Classification</h3>\n<p>The only phase of the 'Classification' step is the 'Log' phase. In this phase, either the end user or an agent determines what the end user is requesting and enters that into the request. If the end user selects a 'Service' type offering, then the request will use the 'Service' workflow.</p>\n<p>In the 'Log' phase the agent must enter a title and description for the request, specify who is making the request (and who it's for if that's a different person), and add the information on how many people the request will impact and how urgent it's (the system uses these last two fields to determine the overall priority of the request).</p>\n<p>To move the request into the next phase, the agent must assign the request either an owner or a responsible group. This is where the finger-pointing really begins! Just kidding, but it's important to get the request to the right people as quickly as possible. Remind me to tell you about some cool functionality we can add using business rules to do this automatically, but we’ll have to get back to that later.</p>\n<p>Once the request has its ownership, it will move into the next phase. This will be the 'Approve' phase if the related offering has approvals defined, or straight into the 'Fulfill' phase if it doesn't. The only other possible transition is to the 'Abandon' phase, which will only happen if an agent manually moves it there (which ends the request life-cycle).</p>\n<p>While this might seem like a lot of information for the agent to handle just to get the process started, remember that the system fills most if not all of this information automatically based on the selected offering. This is why pre-defining the offerings ahead of time is so important. It can reduce the manual effort of our service desk agents during this phase of the request process, and like me, they would like the required effort to be as little as possible.</p>\n<p>Defining a title and impact/urgency information for a password reset request, for example, is straightforward since it's always the same every time it's performed. Assigning a request like this to a specific group may not be as straightforward, however, we’ll go over a great feature Service Management has to help with this later, for now, we can just imagine that we could assign a specific group to an offering.</p>\n<p>If we define the offering with all of this information correctly, when an end user requests it from the Service Portal the system will correctly prioritize and assign the request automatically, and then move to the next phase ('Approve' or 'Fulfill') with no input needed from our agents.</p>\n<h3>Approval</h3>\n<p>The 'Approval' step and the associated 'Approve' phase should be self-explanatory. At this point in the request, any needed approvals take place (and I have my over-sized “DENIED” stamp ready). If the proper people approve the request, it will move into the 'Fulfill' phase, and if not it will move to 'Done' (and the end user will receive a notification that this happened).</p>\n<p>Our agents can see what approvals are necessary and even which ones have already been approved or denied directly from the Request. If they have the right role (remember those?) they can even change who needs to give their thumbs up for a particular approval.</p>\n<div><a class=\"image\" href=\"/file/images/d/d5/5.6-Approval.png\" title=\"/file/images/d/d5/5.6-Approval.png\"> <img alt=\"5.6-Approval.png\" border=\"0\" file=\"/mediawiki/images/d/d5/5.6-Approval.png\" height=\"603\" hspace=\"0\" src=\"../../../images/5.6-Approval_7f876d9c.png\" style=\"width:562px;height:603px;margin-top:0px;margin-bottom:0px;margin-left:0px;margin-right:0px;border:0px solid black;\" vspace=\"0\" width=\"562\"/> </a></div>\n<p>Notice how we can control the logic regarding what approvals the request requires and the order of those approvals. In this example, the system will not process the 'Financial approval' will until someone approves the 'Manager approve' task.</p>\n<p>Another nice thing we can do is allow our Agents to manually add approvals to the process from the request itself. If they have the right role (that we defined earlier, remember) they can click to add new approval requirements to the request, then add the person or group to that new approval.</p>\n<h3>Fulfillment</h3>\n<p>'Fulfillment' is where the work to fulfill the request is done (shocking, I know). With the 'Service' workflow, agents accomplish this by working on tasks that defined in the associated offering and/or any manually created tasks. During the fulfillment step, groups may pass the request back and forth. However, it will always be the responsibility of the owning service desk group to ensure that the request gets completed.</p>\n<p>The owner of the request can view the overall task plan directly from the request to see what tasks are in progress, which are upcoming, and any that might have been unnecessary.</p>\n<div><a class=\"image\" href=\"/file/images/5/55/5.7-FulfillPlan.png\" title=\"/file/images/5/55/5.7-FulfillPlan.png\"> <img alt=\"5.7-FulfillPlan.png\" border=\"0\" file=\"/mediawiki/images/5/55/5.7-FulfillPlan.png\" height=\"800\" hspace=\"0\" src=\"../../../images/5.7-FulfillPlan_1fcac71c.png\" style=\"width: 596.413px; height: 800px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"596.4125560538116\"/> </a></div>\n<p>When an agent (or the system) assigns a task to a person, they get an email notification and can also use the tasks list inside of Service Management to see all the tasks assigned to them.</p>\n<p>The system can handle some of these tasks automatically (such as the 'Reserve PC' task in the above example) and may never need a person to work on them at all. We can use business rules to fill in the information or even call an external tool to do the work in another system. Service Management even has a great built-in integration to Operation Orchestration, which we can use to coordinate work between multiple external systems.</p>\n<p>Once all the tasks have been completed, the Agent simply needs to fill in the solution (a summary of what was done to fulfill the request) and enter a completion code (which describes how the solution fulfilled the problem: 'Resolved with workaround', 'Request denied', etc.) and the system will move the request into the 'Validation step'. For these type of requests, we could even use automated tasks in the task plan to set a solution and completion code if all other tasks complete successfully.</p>\n<p>One other possibility I should point out is what happens if the end user no longer needs the Request to be fulfilled after it has been opened. In this case, the agent can abandon the request, which ends the request process without finishing the requested work.</p>\n<h3>Validation</h3>\n<p>Now that we’ve finished the work associated with the request, are we done? Well, not quite. The result of the request process is to ensure that the resolution satisfies the end user. It's up to the end user to decide if we got things right. That leads us to the 'Validation' step of the request.</p>\n<p>Upon entering the 'Validation' phase, the system places the request into the 'Accept' phase. When this happens, the end user receives an email notifying them of the resolution and asking them for their feedback.</p>\n<div><a class=\"image\" href=\"/file/images/e/e2/5.8-SolutionEmail_new.png\" title=\"/file/images/e/e2/5.8-SolutionEmail_new.png\"> <img alt=\"5.8-SolutionEmail.png\" border=\"0\" file=\"https://staging.docs.microfocus.com/mediawiki/images/e/e2/5.8-SolutionEmail_new.png\" height=\"302\" hspace=\"0\" src=\"../../../images/5.8-SolutionEmail_new_f1a88263.png\" style=\"width:577px;height:302px;margin-top:0px;margin-bottom:0px;margin-left:0px;margin-right:0px;border:0px solid black;\" vspace=\"0\" width=\"577\"/> </a></div>\n<p>If the end user selects the 'Accept' button, the system closes the request and completes the process.</p>\n<p>If we didn't completely solve their issue, or they want to give feedback on the process, they use the 'Add comments' button. This brings up the original request and allows them to leave whatever comments they wish. After they leave their comments, the request automatically enters the 'Review' phase. Now it's up to the responsible agent to review the user’s comments and decide if they can close the request or need to move it back to the 'Fulfillment' step.</p>\n<h2>Support Workflow</h2>\n<p>Not every end user request will fit into our pre-defined service catalog. Sometimes people will enter requests because they are having an issue with a service we provide. To handle these types of requests, we use support requests.</p>\n<div><a class=\"image\" href=\"/file/images/1/14/6.1_-_SupportWorkflow.png\" title=\"/file/images/1/14/6.1_-_SupportWorkflow.png\"> <img alt=\"6.1 - SupportWorkflow.png\" border=\"0\" file=\"/mediawiki/images/1/14/6.1_-_SupportWorkflow.png\" height=\"366\" hspace=\"0\" src=\"../../../images/6.1_-_SupportWorkflow_9ad52641.png\" style=\"width: 800px; height: 366px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>Support requests are similar to service requests, but let’s take a look at each step of the process and look at the differences.</p>\n<h3>Classification</h3>\n<p>While both workflows start with the ‘Log’ phase, the ‘Support request’ workflow adds a second phase to the ‘Classification’ step. In the ‘Classify’ phase, the service desk agent can enter additional information about the end user’s issue and set other information such as the service they are having an issue with and an initial category for the request. At this point, the agent must also assign the request to either a group or an agent.</p>\n<h3>Approval</h3>\n<p>Support requests have no pre-defined approvals, so the workflow skips this step.</p>\n<h3>Fulfillment</h3>\n<p>Instead of a single fulfillment phase, the support request has the ‘First level support’ and ‘Escalate’ phases.</p>\n<p>The ‘First level support’ phase is where the actual work starts, and our agents often complete many requests in this phase. Just like service requests, the work can perform the work directly in the request or in tasks assigned to multiple people in parallel.</p>\n<p>The primary difference in the workflows is the ability to escalate a support request (into the ‘Escalate’ phase, of course). An agent works an escalated support case in the same way, however, the system sends out additional notifications during the process. For example, an escalated request might send notifications to the owner of the affected service.</p>\n<h3>Validation</h3>\n<p>The ‘Validation’ step is identical between both workflows. The end user is emailed to determine whether or not the request was completed successfully.</p>\n<h2>HR Support Workflow</h2>\n<p>Not everyone calls the Service Desk with an IT related question. Over time, we have seen more and more requests coming in for services provided by Human Resources. Luckily, Service Management’s request module has a process that caters exclusively to these types of requests. This allows our organization to integrate its HR operations as a part of request management, benefiting from a familiar data structure, workflow, reports, and so on.</p>\n<div><a class=\"image\" href=\"/file/images/2/29/HRSupport_workflow.png\" title=\"/file/images/2/29/HRSupport_workflow.png\"> <img alt=\"HRSupport workflow.png\" border=\"0\" file=\"/mediawiki/images/2/29/HRSupport_workflow.png\" height=\"316\" hspace=\"0\" src=\"../../../images/HRSupport_workflow_d8cab363.png\" style=\"width: 800px; height: 316px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>We can configure and manage our HR support requests separately from Service Catalog processes and streamline processes that don't require approval or validation.</p>\n<h3>Classification</h3>\n<p>HR support workflow provides both the 'Log' and 'Classify' phases, which operate similarly to the same phases in the support workflow. In these phases, the service desk agent ensures that the request is entered correctly, and assigns it to an agent or a group.</p>\n<h3>Fulfillment</h3>\n<p>In the 'Process' phase, the assigned agent performs the actions needed to complete the Request. This often involves specific tasks associated with the request, which may be handled by a different agent (or HR representative in this case). Once they complete the actions, the agent provides a solution and completion code and closes the Request.</p>\n<h3>Validation</h3>\n<p>The 'Validation' step is the same as the other request workflows. The end user is emailed to determine whether the Request was completed successfully.</p>\n<p>If that wasn’t detailed enough for you, check out the full descriptions of the <a href=\"/doc/423/26.1/srmwflw\" title=\"service request workflows\">service request workflows</a> online.</p>\n<h2 id=\"Cart_Workflow\">Cart Workflow</h2>\n<p>The Request module has a special workflow for shopping cart requests. For these requests, Service Management creates a single request that handles the overall approval, and then a separate request for each item added to the cart. The first request uses the cart workflow.</p>\n<div><a class=\"image\" href=\"/file/images/a/ac/cart_request_workfow.png\" title=\"/file/images/a/ac/cart_request_workfow.png\"> <img alt=\"cart request workfow.png\" border=\"0\" file=\"/mediawiki/images/a/ac/cart_request_workfow.png\" height=\"284\" hspace=\"0\" src=\"../../../images/cart_request_workfow_e7c71af6.png\" style=\"width: 800px; height: 284px; margin: 0px; border: 0px solid black;\" vspace=\"0\" width=\"800\"/> </a></div>\n<p>Until the first request reaches the 'Close phase, all child requests will remain in their own 'Log' phase.</p>\n<h3>Classification</h3>\n<p>The system processes the 'Log' phase with no input from the agent. Its only function is to determine if there are any needed approvals or not. If there are, the request proceeds to the 'Approval' step. If not, it processes to the 'Done' step.</p>\n<h3>Approval</h3>\n<p>In the 'Approve' phase, the system processes all necessary approvals. This works identically to the 'Approval' step in a service workflow.</p>\n<p>Once the cart request is completed, the child requests may be processed.</p>\n<h2>Service Level Targets</h2>\n<p>One thing regarding the request workflow I want to mention is the service level targets the system calculates for the request. These targets measure the time it takes between certain steps in the process (the most important being the time between the Request being created and resolved).</p>\n<p>Service level targets are defined by the service level management process, which we will cover later. For now, it's enough to know the target times for the request are determined by a combination of:</p>\n<ul>\n<li>The service specified in the request</li>\n<li>The priority of the request (which is calculated by the specified urgency and impact)</li>\n</ul>\n<p>This results in the high-priority requests having a shorter target time than those of low priority. Here’s a useful tip: sorting a list of requests by the next target time gives an agent a great idea of what order they should tackle them in.</p>\n<!-- NewPP limit reportCached time: 20200216212413Cache expiry: 86400Dynamic content: falseCPU time usage: 0.032 secondsReal time usage: 0.184 secondsPreprocessor visited node count: 31/1000000Preprocessor generated node count: 72/1000000Post‐expand include size: 16434/2097152 bytesTemplate argument size: 0/2097152 bytesHighest expansion depth: 2/40Expensive parser function count: 0/100Unstrip recursion depth: 0/20Unstrip post‐expand size: 0/5000000 bytes--><!--Transclusion expansion time report (%,ms,calls,template)100.00%    0.000      1 -total--></div>\n<div></div>\n<p class=\"mw-empty-elt\"></p></div>",
  "modifiedon": "2025-10-24 08:51:12"
}